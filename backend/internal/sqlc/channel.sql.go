// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: channel.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createGuildChannel = `-- name: CreateGuildChannel :one
INSERT INTO channels (guild_id, name, topic, channel_type, creator_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, topic, channel_type, parent_id, creator_id, guild_id, created_at, updated_at
`

type CreateGuildChannelParams struct {
	GuildID     pgtype.UUID
	Name        string
	Topic       string
	ChannelType int16
	CreatorID   uuid.UUID
}

func (q *Queries) CreateGuildChannel(ctx context.Context, arg CreateGuildChannelParams) (Channel, error) {
	row := q.db.QueryRow(ctx, createGuildChannel,
		arg.GuildID,
		arg.Name,
		arg.Topic,
		arg.ChannelType,
		arg.CreatorID,
	)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Topic,
		&i.ChannelType,
		&i.ParentID,
		&i.CreatorID,
		&i.GuildID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPrivateChannel = `-- name: CreatePrivateChannel :one
INSERT INTO channels (channel_type, creator_id)
VALUES ($1, $2)
RETURNING id, name, topic, channel_type, parent_id, creator_id, guild_id, created_at, updated_at
`

type CreatePrivateChannelParams struct {
	ChannelType int16
	CreatorID   uuid.UUID
}

func (q *Queries) CreatePrivateChannel(ctx context.Context, arg CreatePrivateChannelParams) (Channel, error) {
	row := q.db.QueryRow(ctx, createPrivateChannel, arg.ChannelType, arg.CreatorID)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Topic,
		&i.ChannelType,
		&i.ParentID,
		&i.CreatorID,
		&i.GuildID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPrivateChannelRecipients = `-- name: CreatePrivateChannelRecipients :execrows
INSERT INTO channel_users (channel_id, user_id)
SELECT $1, id FROM users
WHERE id = ANY($2::uuid[])
`

type CreatePrivateChannelRecipientsParams struct {
	ChannelID uuid.UUID
	UserIds   []uuid.UUID
}

func (q *Queries) CreatePrivateChannelRecipients(ctx context.Context, arg CreatePrivateChannelRecipientsParams) (int64, error) {
	result, err := q.db.Exec(ctx, createPrivateChannelRecipients, arg.ChannelID, arg.UserIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteGuildChannel = `-- name: DeleteGuildChannel :execrows
DELETE
FROM
channels
WHERE
id = $1
AND
guild_id = $2::uuid
`

type DeleteGuildChannelParams struct {
	ChannelID uuid.UUID
	GuildID   uuid.UUID
}

func (q *Queries) DeleteGuildChannel(ctx context.Context, arg DeleteGuildChannelParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGuildChannel, arg.ChannelID, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getManyGuildChannelsByGuildID = `-- name: GetManyGuildChannelsByGuildID :many
WITH guild_channels_cte AS (
  SELECT id, name, topic, channel_type, parent_id, creator_id, guild_id, created_at, updated_at
  FROM channels
  WHERE guild_id = $1::uuid
),

guild_role_channels_cte AS (
  SELECT channel_id, ARRAY_AGG(role_id) AS roles
  FROM guild_role_channels
  WHERE channel_id IN (
    SELECT id FROM guild_channels_cte
  ) GROUP BY channel_id
)

SELECT gcc.id, gcc.name, gcc.topic, gcc.channel_type, gcc.parent_id, gcc.creator_id, gcc.guild_id, gcc.created_at, gcc.updated_at, grcc.roles::UUID[] as roles
FROM guild_channels_cte gcc
INNER JOIN guild_role_channels_cte grcc ON grcc.channel_id = gcc.id
`

type GetManyGuildChannelsByGuildIDRow struct {
	ID          uuid.UUID
	Name        string
	Topic       string
	ChannelType int16
	ParentID    pgtype.UUID
	CreatorID   uuid.UUID
	GuildID     pgtype.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Roles       []uuid.UUID
}

func (q *Queries) GetManyGuildChannelsByGuildID(ctx context.Context, guildID uuid.UUID) ([]GetManyGuildChannelsByGuildIDRow, error) {
	rows, err := q.db.Query(ctx, getManyGuildChannelsByGuildID, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyGuildChannelsByGuildIDRow{}
	for rows.Next() {
		var i GetManyGuildChannelsByGuildIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Topic,
			&i.ChannelType,
			&i.ParentID,
			&i.CreatorID,
			&i.GuildID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrivateChannelByUsers = `-- name: GetPrivateChannelByUsers :one
WITH private_channel_cte AS (
    SELECT channel_id
    FROM channel_users
    WHERE user_id = ANY($1::uuid[])
    GROUP BY channel_id
    HAVING COUNT(*) = $2::int
    LIMIT 1
)

SELECT
id, name, topic, channel_type, parent_id, creator_id, guild_id, created_at, updated_at
FROM
channels
WHERE
id = (
    SELECT
    channel_id
    FROM
    private_channel_cte
)
`

type GetPrivateChannelByUsersParams struct {
	UserIds  []uuid.UUID
	UsersLen int32
}

func (q *Queries) GetPrivateChannelByUsers(ctx context.Context, arg GetPrivateChannelByUsersParams) (Channel, error) {
	row := q.db.QueryRow(ctx, getPrivateChannelByUsers, arg.UserIds, arg.UsersLen)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Topic,
		&i.ChannelType,
		&i.ParentID,
		&i.CreatorID,
		&i.GuildID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPrivateChannelUserByChannelIDAndUserID = `-- name: GetPrivateChannelUserByChannelIDAndUserID :execrows
SELECT 1
FROM channel_users
WHERE channel_id = $1 AND user_id = $2
LIMIT 1
`

type GetPrivateChannelUserByChannelIDAndUserIDParams struct {
	ChannelID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) GetPrivateChannelUserByChannelIDAndUserID(ctx context.Context, arg GetPrivateChannelUserByChannelIDAndUserIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, getPrivateChannelUserByChannelIDAndUserID, arg.ChannelID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateChannel = `-- name: UpdateChannel :one
UPDATE channels
SET
name = (
CASE
    WHEN $1::text IS NOT NULL THEN $1::text
    ELSE channels.name
END
),
topic = (
CASE
    WHEN $2::text IS NOT NULL THEN $2::text
    ELSE channels.topic
END
)
WHERE
id = $3
RETURNING id, name, topic, channel_type, parent_id, creator_id, guild_id, created_at, updated_at
`

type UpdateChannelParams struct {
	Name      pgtype.Text
	Topic     pgtype.Text
	ChannelID uuid.UUID
}

func (q *Queries) UpdateChannel(ctx context.Context, arg UpdateChannelParams) (Channel, error) {
	row := q.db.QueryRow(ctx, updateChannel, arg.Name, arg.Topic, arg.ChannelID)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Topic,
		&i.ChannelType,
		&i.ParentID,
		&i.CreatorID,
		&i.GuildID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGuildChannelCategory = `-- name: UpdateGuildChannelCategory :one
UPDATE channels
SET name = $1
WHERE id = $2 RETURNING id, name, topic, channel_type, parent_id, creator_id, guild_id, created_at, updated_at
`

type UpdateGuildChannelCategoryParams struct {
	Name      string
	ChannelID uuid.UUID
}

func (q *Queries) UpdateGuildChannelCategory(ctx context.Context, arg UpdateGuildChannelCategoryParams) (Channel, error) {
	row := q.db.QueryRow(ctx, updateGuildChannelCategory, arg.Name, arg.ChannelID)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Topic,
		&i.ChannelType,
		&i.ParentID,
		&i.CreatorID,
		&i.GuildID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

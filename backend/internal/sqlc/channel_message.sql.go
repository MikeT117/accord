// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: channel_message.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createChannelMessage = `-- name: CreateChannelMessage :one
WITH channel_message_insert_cte AS (
    INSERT INTO channel_messages (content, user_id, channel_id, guild_id)
    SELECT $1, $2, c.id, c.guild_id
    FROM channels c
    WHERE c.id = $3
    RETURNING id, content, is_pinned, flags, user_id, channel_id, guild_id, created_at, updated_at
),

channel_messages_cte AS (
    SELECT
    cmicte.id,
    cmicte.user_id,
    cmicte.channel_id,
    cmicte.content,
    cmicte.is_pinned,
    cmicte.flags,
    cmicte.created_at,
    cmicte.updated_at,
    CASE
        WHEN gm.nickname IS NOT NULL THEN gm.nickname
        ELSE u.display_name
    END::text AS display_name,
    u.username,
    u.public_flags,
    ua.attachment_id
    FROM channel_message_insert_cte cmicte
    INNER JOIN users u ON u.id = cmicte.user_id
    LEFT JOIN user_attachments ua ON ua.user_id = u.id
    LEFT JOIN guild_members gm ON gm.guild_id = cmicte.guild_id AND cmicte.user_id = gm.user_id
),

attachments_cte AS (
    SELECT cma.channel_message_id, ARRAY_AGG(cma.attachment_id)::text[] AS attachments
    FROM channel_message_attachments cma
    INNER JOIN channel_messages_cte cmcte ON cmcte.id = cma.channel_message_id
    GROUP BY cma.channel_message_id
)

SELECT cmcte.id, cmcte.user_id, cmcte.channel_id, cmcte.content, cmcte.is_pinned, cmcte.flags, cmcte.created_at, cmcte.updated_at, cmcte.display_name, cmcte.username, cmcte.public_flags, cmcte.attachment_id, COALESCE(acte.attachments, '{}')
FROM channel_messages_cte cmcte
LEFT JOIN attachments_cte acte ON acte.channel_message_id = cmcte.id
`

type CreateChannelMessageParams struct {
	Content   string
	UserID    uuid.UUID
	ChannelID uuid.UUID
}

type CreateChannelMessageRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	ChannelID    uuid.UUID
	Content      string
	IsPinned     bool
	Flags        int32
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	DisplayName  string
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
	Attachments  []string
}

func (q *Queries) CreateChannelMessage(ctx context.Context, arg CreateChannelMessageParams) (CreateChannelMessageRow, error) {
	row := q.db.QueryRow(ctx, createChannelMessage, arg.Content, arg.UserID, arg.ChannelID)
	var i CreateChannelMessageRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelID,
		&i.Content,
		&i.IsPinned,
		&i.Flags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisplayName,
		&i.Username,
		&i.PublicFlags,
		&i.AttachmentID,
		&i.Attachments,
	)
	return i, err
}

const deleteChannelMessage = `-- name: DeleteChannelMessage :one
DELETE FROM channel_messages
WHERE id = $1 AND channel_id = $2
RETURNING id, channel_id
`

type DeleteChannelMessageParams struct {
	MessageID uuid.UUID
	ChannelID uuid.UUID
}

type DeleteChannelMessageRow struct {
	ID        uuid.UUID
	ChannelID uuid.UUID
}

func (q *Queries) DeleteChannelMessage(ctx context.Context, arg DeleteChannelMessageParams) (DeleteChannelMessageRow, error) {
	row := q.db.QueryRow(ctx, deleteChannelMessage, arg.MessageID, arg.ChannelID)
	var i DeleteChannelMessageRow
	err := row.Scan(&i.ID, &i.ChannelID)
	return i, err
}

const getManyChannelMessagesByChannelID = `-- name: GetManyChannelMessagesByChannelID :many
WITH channel_messages_cte AS (
    SELECT
    cm.id,
    cm.user_id,
    cm.channel_id,
    cm.content,
    cm.is_pinned,
    cm.flags,
    cm.created_at,
    cm.updated_at,
    CASE
        WHEN gm.nickname IS NOT NULL THEN gm.nickname
        ELSE u.display_name
    END::text AS display_name,
    u.username,
    u.public_flags,
    ua.attachment_id
    FROM channel_messages cm
    INNER JOIN users u ON u.id = cm.user_id
    LEFT JOIN user_attachments ua ON ua.user_id = u.id
    LEFT JOIN guild_members gm ON gm.guild_id = cm.guild_id AND cm.user_id = gm.user_id
    WHERE cm.channel_id = $1 AND
    (CASE
        WHEN $2::timestamp IS NOT NULL THEN cm.created_at < $2::timestamp
        ELSE TRUE
    END)
    AND 
    (CASE
        WHEN $3::timestamp IS NOT NULL THEN cm.created_at > $3::timestamp
        ELSE TRUE
    END)
    ORDER BY cm.created_at DESC
    LIMIT $4
),

attachments_cte AS (
    SELECT cma.channel_message_id, ARRAY_AGG(cma.attachment_id)::text[] AS attachments
    FROM channel_message_attachments cma
    INNER JOIN channel_messages_cte cmcte ON cmcte.id = cma.channel_message_id
    GROUP BY cma.channel_message_id
)

SELECT cmcte.id, cmcte.user_id, cmcte.channel_id, cmcte.content, cmcte.is_pinned, cmcte.flags, cmcte.created_at, cmcte.updated_at, cmcte.display_name, cmcte.username, cmcte.public_flags, cmcte.attachment_id, COALESCE(acte.attachments, '{}')
FROM channel_messages_cte cmcte
LEFT JOIN attachments_cte acte ON acte.channel_message_id = cmcte.id
`

type GetManyChannelMessagesByChannelIDParams struct {
	ChannelID    uuid.UUID
	Before       pgtype.Timestamp
	After        pgtype.Timestamp
	ResultsLimit int64
}

type GetManyChannelMessagesByChannelIDRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	ChannelID    uuid.UUID
	Content      string
	IsPinned     bool
	Flags        int32
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	DisplayName  string
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
	Attachments  []string
}

func (q *Queries) GetManyChannelMessagesByChannelID(ctx context.Context, arg GetManyChannelMessagesByChannelIDParams) ([]GetManyChannelMessagesByChannelIDRow, error) {
	rows, err := q.db.Query(ctx, getManyChannelMessagesByChannelID,
		arg.ChannelID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyChannelMessagesByChannelIDRow{}
	for rows.Next() {
		var i GetManyChannelMessagesByChannelIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ChannelID,
			&i.Content,
			&i.IsPinned,
			&i.Flags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisplayName,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
			&i.Attachments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pinChannelMessage = `-- name: PinChannelMessage :execrows
UPDATE channel_messages
SET is_pinned = true
WHERE id = $1 AND channel_id = $2
RETURNING id, channel_id, content, is_pinned
`

type PinChannelMessageParams struct {
	MessageID uuid.UUID
	ChannelID uuid.UUID
}

type PinChannelMessageRow struct {
	ID        uuid.UUID
	ChannelID uuid.UUID
	Content   string
	IsPinned  bool
}

func (q *Queries) PinChannelMessage(ctx context.Context, arg PinChannelMessageParams) (int64, error) {
	result, err := q.db.Exec(ctx, pinChannelMessage, arg.MessageID, arg.ChannelID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const unpinChannelMessage = `-- name: UnpinChannelMessage :execrows
UPDATE channel_messages
SET is_pinned = false
WHERE id = $1 AND channel_id = $2
RETURNING id, channel_id, content, is_pinned
`

type UnpinChannelMessageParams struct {
	MessageID uuid.UUID
	ChannelID uuid.UUID
}

type UnpinChannelMessageRow struct {
	ID        uuid.UUID
	ChannelID uuid.UUID
	Content   string
	IsPinned  bool
}

func (q *Queries) UnpinChannelMessage(ctx context.Context, arg UnpinChannelMessageParams) (int64, error) {
	result, err := q.db.Exec(ctx, unpinChannelMessage, arg.MessageID, arg.ChannelID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateChannelMessage = `-- name: UpdateChannelMessage :one
UPDATE channel_messages
SET content = $1, updated_at = NOW()
WHERE id = $2 AND channel_id = $3
RETURNING id, channel_id, content, is_pinned, updated_at
`

type UpdateChannelMessageParams struct {
	Content   string
	MessageID uuid.UUID
	ChannelID uuid.UUID
}

type UpdateChannelMessageRow struct {
	ID        uuid.UUID
	ChannelID uuid.UUID
	Content   string
	IsPinned  bool
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) UpdateChannelMessage(ctx context.Context, arg UpdateChannelMessageParams) (UpdateChannelMessageRow, error) {
	row := q.db.QueryRow(ctx, updateChannelMessage, arg.Content, arg.MessageID, arg.ChannelID)
	var i UpdateChannelMessageRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.Content,
		&i.IsPinned,
		&i.UpdatedAt,
	)
	return i, err
}

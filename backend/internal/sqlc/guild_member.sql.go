// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: guild_member.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createGuildMember = `-- name: CreateGuildMember :one
INSERT INTO guild_members (nickname, guild_id, user_id)
VALUES ($1, $2, $3)
RETURNING nickname, joined_at, updated_at, user_id, guild_id
`

type CreateGuildMemberParams struct {
	Nickname pgtype.Text
	GuildID  uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) CreateGuildMember(ctx context.Context, arg CreateGuildMemberParams) (GuildMember, error) {
	row := q.db.QueryRow(ctx, createGuildMember, arg.Nickname, arg.GuildID, arg.UserID)
	var i GuildMember
	err := row.Scan(
		&i.Nickname,
		&i.JoinedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.GuildID,
	)
	return i, err
}

const deleteGuildMember = `-- name: DeleteGuildMember :one
DELETE FROM guild_members
WHERE user_id = $1 AND guild_id = $2
RETURNING user_id, guild_id
`

type DeleteGuildMemberParams struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

type DeleteGuildMemberRow struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) DeleteGuildMember(ctx context.Context, arg DeleteGuildMemberParams) (DeleteGuildMemberRow, error) {
	row := q.db.QueryRow(ctx, deleteGuildMember, arg.UserID, arg.GuildID)
	var i DeleteGuildMemberRow
	err := row.Scan(&i.UserID, &i.GuildID)
	return i, err
}

const getManyAssignableGuildMembersByGuildIDAndRoleID = `-- name: GetManyAssignableGuildMembersByGuildIDAndRoleID :many
WITH guild_member_cte AS (
	SELECT
    gm.joined_at,
    CASE
        WHEN gm.nickname IS NOT NULL THEN gm.nickname
        ELSE u.display_name
    END::text AS display_name,
    u.id,
    u.username,
    u.public_flags,
    ua.attachment_id
	FROM guild_members gm
	INNER JOIN users u ON u.id = gm.user_id
	LEFT JOIN user_attachments ua ON ua.user_id = gm.user_id
    WHERE
    gm.guild_id = $1
    AND
    NOT EXISTS (
        SELECT
        1
        FROM
		guild_role_users gru
		WHERE
        gru.role_id = $2
        AND
        gru.user_id = gm.user_id
    )
    AND
    (CASE
        WHEN $3::uuid IS NOT NULL THEN gm.user_id < $3::uuid
        ELSE TRUE
    END)
    AND
    (CASE
	    WHEN $4::uuid IS NOT NULL THEN gm.user_id > $4::uuid
	    ELSE TRUE
    END)
    ORDER BY u.id DESC
	LIMIT $5
),

user_roles_cte AS (
	SELECT gru.user_id, ARRAY_AGG(gru.role_id)::uuid[] AS roles
	FROM guild_role_users gru
    INNER JOIN guild_roles gr ON gr.id = gru.role_id AND gr.guild_id = $1
	INNER JOIN guild_member_cte gmcte ON gmcte.id = gru.user_id
	GROUP BY gru.user_id
)

SELECT gmcte.joined_at, gmcte.display_name, gmcte.id, gmcte.username, gmcte.public_flags, gmcte.attachment_id, urcte.roles
FROM guild_member_cte gmcte
INNER JOIN user_roles_cte urcte ON urcte.user_id = gmcte.id
ORDER BY gmcte.id DESC
`

type GetManyAssignableGuildMembersByGuildIDAndRoleIDParams struct {
	GuildID      uuid.UUID
	RoleID       uuid.UUID
	Before       pgtype.UUID
	After        pgtype.UUID
	ResultsLimit int64
}

type GetManyAssignableGuildMembersByGuildIDAndRoleIDRow struct {
	JoinedAt     pgtype.Timestamp
	DisplayName  string
	ID           uuid.UUID
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
	Roles        []uuid.UUID
}

func (q *Queries) GetManyAssignableGuildMembersByGuildIDAndRoleID(ctx context.Context, arg GetManyAssignableGuildMembersByGuildIDAndRoleIDParams) ([]GetManyAssignableGuildMembersByGuildIDAndRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getManyAssignableGuildMembersByGuildIDAndRoleID,
		arg.GuildID,
		arg.RoleID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyAssignableGuildMembersByGuildIDAndRoleIDRow{}
	for rows.Next() {
		var i GetManyAssignableGuildMembersByGuildIDAndRoleIDRow
		if err := rows.Scan(
			&i.JoinedAt,
			&i.DisplayName,
			&i.ID,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyGuildMembersByGuildID = `-- name: GetManyGuildMembersByGuildID :many
WITH guild_member_cte AS (
	SELECT
    gm.joined_at,
    CASE
        WHEN gm.nickname IS NOT NULL THEN gm.nickname
        ELSE u.display_name
    END::text AS display_name,
    u.id,
    u.username,
    u.public_flags,
    ua.attachment_id
	FROM guild_members gm
	INNER JOIN users u ON u.id = gm.user_id
	LEFT JOIN user_attachments ua ON ua.user_id = gm.user_id
    WHERE gm.guild_id = $1 AND 
    (CASE
        WHEN $2::uuid IS NOT NULL THEN gm.user_id < $2::uuid
        ELSE TRUE
    END)
    AND
    (CASE
	    WHEN $3::uuid IS NOT NULL THEN gm.user_id > $3::uuid
	    ELSE TRUE
    END)
    ORDER BY gm.user_id
	LIMIT $4
),

user_roles_cte AS (
	SELECT gru.user_id, ARRAY_AGG(gru.role_id)::uuid[] AS roles
	FROM guild_role_users gru
    INNER JOIN guild_roles gr ON gr.id = gru.role_id AND gr.guild_id = $1
	INNER JOIN guild_member_cte gmcte ON gmcte.id = gru.user_id
	GROUP BY gru.user_id
)

SELECT gmcte.joined_at, gmcte.display_name, gmcte.id, gmcte.username, gmcte.public_flags, gmcte.attachment_id, urcte.roles
FROM guild_member_cte gmcte
INNER JOIN user_roles_cte urcte ON urcte.user_id = gmcte.id
ORDER BY gmcte.id
`

type GetManyGuildMembersByGuildIDParams struct {
	GuildID      uuid.UUID
	Before       pgtype.UUID
	After        pgtype.UUID
	ResultsLimit int64
}

type GetManyGuildMembersByGuildIDRow struct {
	JoinedAt     pgtype.Timestamp
	DisplayName  string
	ID           uuid.UUID
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
	Roles        []uuid.UUID
}

func (q *Queries) GetManyGuildMembersByGuildID(ctx context.Context, arg GetManyGuildMembersByGuildIDParams) ([]GetManyGuildMembersByGuildIDRow, error) {
	rows, err := q.db.Query(ctx, getManyGuildMembersByGuildID,
		arg.GuildID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyGuildMembersByGuildIDRow{}
	for rows.Next() {
		var i GetManyGuildMembersByGuildIDRow
		if err := rows.Scan(
			&i.JoinedAt,
			&i.DisplayName,
			&i.ID,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyUnassignableGuildMembersByGuildIDAndRoleID = `-- name: GetManyUnassignableGuildMembersByGuildIDAndRoleID :many
WITH guild_member_cte AS (
	SELECT
    gm.joined_at,
    CASE
        WHEN gm.nickname IS NOT NULL THEN gm.nickname
        ELSE u.display_name
    END::text AS display_name,
    u.id,
    u.username,
    u.public_flags,
    ua.attachment_id
	FROM guild_members gm
	INNER JOIN users u ON u.id = gm.user_id
    INNER JOIN guild_role_users gru ON gru.user_id = gm.user_id
	LEFT JOIN user_attachments ua ON ua.user_id = gm.user_id
    WHERE
    gm.guild_id = $1
    AND
    gru.role_id = $2
    AND
    (CASE
        WHEN $3::uuid IS NOT NULL THEN gm.user_id < $3::uuid
        ELSE TRUE
    END)
    AND
    (CASE
	    WHEN $4::uuid IS NOT NULL THEN gm.user_id > $4::uuid
	    ELSE TRUE
    END)
    ORDER BY gm.user_id DESC
	LIMIT $5
),

user_roles_cte AS (
	SELECT gru.user_id, ARRAY_AGG(gru.role_id)::uuid[] AS roles
	FROM guild_role_users gru
    INNER JOIN guild_roles gr ON gr.id = gru.role_id AND gr.guild_id = $1
	INNER JOIN guild_member_cte gmcte ON gmcte.id = gru.user_id
	GROUP BY gru.user_id
)

SELECT gmcte.joined_at, gmcte.display_name, gmcte.id, gmcte.username, gmcte.public_flags, gmcte.attachment_id, urcte.roles
FROM guild_member_cte gmcte
INNER JOIN user_roles_cte urcte ON urcte.user_id = gmcte.id
ORDER BY gmcte.id DESC
`

type GetManyUnassignableGuildMembersByGuildIDAndRoleIDParams struct {
	GuildID      uuid.UUID
	RoleID       uuid.UUID
	Before       pgtype.UUID
	After        pgtype.UUID
	ResultsLimit int64
}

type GetManyUnassignableGuildMembersByGuildIDAndRoleIDRow struct {
	JoinedAt     pgtype.Timestamp
	DisplayName  string
	ID           uuid.UUID
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
	Roles        []uuid.UUID
}

func (q *Queries) GetManyUnassignableGuildMembersByGuildIDAndRoleID(ctx context.Context, arg GetManyUnassignableGuildMembersByGuildIDAndRoleIDParams) ([]GetManyUnassignableGuildMembersByGuildIDAndRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getManyUnassignableGuildMembersByGuildIDAndRoleID,
		arg.GuildID,
		arg.RoleID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyUnassignableGuildMembersByGuildIDAndRoleIDRow{}
	for rows.Next() {
		var i GetManyUnassignableGuildMembersByGuildIDAndRoleIDRow
		if err := rows.Scan(
			&i.JoinedAt,
			&i.DisplayName,
			&i.ID,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGuildMember = `-- name: UpdateGuildMember :execrows
UPDATE guild_members
SET nickname = $1
WHERE guild_id = $2 AND user_id = $3
`

type UpdateGuildMemberParams struct {
	Nickname pgtype.Text
	GuildID  uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) UpdateGuildMember(ctx context.Context, arg UpdateGuildMemberParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateGuildMember, arg.Nickname, arg.GuildID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

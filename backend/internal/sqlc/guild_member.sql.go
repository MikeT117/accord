// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: guild_member.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createGuildBan = `-- name: CreateGuildBan :execrows
INSERT INTO guild_bans
(user_id, reason, guild_id, creator_id)
SELECT id, $1, $2, $3
FROM users
WHERE id = $4
`

type CreateGuildBanParams struct {
	Reason    string
	GuildID   uuid.UUID
	CreatorID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) CreateGuildBan(ctx context.Context, arg CreateGuildBanParams) (int64, error) {
	result, err := q.db.Exec(ctx, createGuildBan,
		arg.Reason,
		arg.GuildID,
		arg.CreatorID,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createGuildMember = `-- name: CreateGuildMember :one
INSERT INTO guild_members (nickname, guild_id, user_id)
VALUES ($1, $2, $3)
RETURNING nickname, joined_at, updated_at, user_id, guild_id
`

type CreateGuildMemberParams struct {
	Nickname pgtype.Text
	GuildID  uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) CreateGuildMember(ctx context.Context, arg CreateGuildMemberParams) (GuildMember, error) {
	row := q.db.QueryRow(ctx, createGuildMember, arg.Nickname, arg.GuildID, arg.UserID)
	var i GuildMember
	err := row.Scan(
		&i.Nickname,
		&i.JoinedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.GuildID,
	)
	return i, err
}

const deleteGuildBan = `-- name: DeleteGuildBan :execrows
DELETE FROM guild_bans
WHERE user_id  = $1 AND guild_id = $2
`

type DeleteGuildBanParams struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) DeleteGuildBan(ctx context.Context, arg DeleteGuildBanParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGuildBan, arg.UserID, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteGuildMember = `-- name: DeleteGuildMember :one
DELETE FROM guild_members
WHERE user_id = $1 AND guild_id = $2
RETURNING user_id, guild_id
`

type DeleteGuildMemberParams struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

type DeleteGuildMemberRow struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) DeleteGuildMember(ctx context.Context, arg DeleteGuildMemberParams) (DeleteGuildMemberRow, error) {
	row := q.db.QueryRow(ctx, deleteGuildMember, arg.UserID, arg.GuildID)
	var i DeleteGuildMemberRow
	err := row.Scan(&i.UserID, &i.GuildID)
	return i, err
}

const getManyGuildBansByGuildID = `-- name: GetManyGuildBansByGuildID :many
SELECT
    gb.banned_at,
    gb.reason,
    u.id,
    u.display_name,
    u.username,
    u.public_flags,
    ua.attachment_id
FROM guild_bans gb
INNER JOIN users u ON u.id = gb.user_id
LEFT JOIN user_attachments ua ON ua.user_id = u.id
WHERE gb.guild_id = $1 AND 
    (CASE
        WHEN $2::timestamp IS NOT NULL THEN gb.banned_at < $2::timestamp
        ELSE TRUE
    END)
    AND
    (CASE
	    WHEN $3::timestamp IS NOT NULL THEN gb.banned_at > $3::timestamp
	    ELSE TRUE
    END)
ORDER BY gb.banned_at DESC
LIMIT $4
`

type GetManyGuildBansByGuildIDParams struct {
	GuildID      uuid.UUID
	Before       pgtype.Timestamp
	After        pgtype.Timestamp
	ResultsLimit int64
}

type GetManyGuildBansByGuildIDRow struct {
	BannedAt     pgtype.Timestamp
	Reason       string
	ID           uuid.UUID
	DisplayName  string
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
}

func (q *Queries) GetManyGuildBansByGuildID(ctx context.Context, arg GetManyGuildBansByGuildIDParams) ([]GetManyGuildBansByGuildIDRow, error) {
	rows, err := q.db.Query(ctx, getManyGuildBansByGuildID,
		arg.GuildID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyGuildBansByGuildIDRow{}
	for rows.Next() {
		var i GetManyGuildBansByGuildIDRow
		if err := rows.Scan(
			&i.BannedAt,
			&i.Reason,
			&i.ID,
			&i.DisplayName,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyGuildMembersByGuildID = `-- name: GetManyGuildMembersByGuildID :many
WITH guild_member_cte AS (
	SELECT
    gm.joined_at,
    CASE
        WHEN gm.nickname IS NOT NULL THEN gm.nickname
        ELSE u.display_name
    END::text AS display_name,
    u.id,
    u.username,
    u.public_flags,
    ua.attachment_id
	FROM guild_members gm
	INNER JOIN users u ON u.id = gm.user_id
	LEFT JOIN user_attachments ua ON ua.user_id = gm.user_id
    WHERE gm.guild_id = $1 AND 
    (CASE
        WHEN $2::timestamp IS NOT NULL THEN gm.joined_at < $2::timestamp
        ELSE TRUE
    END)
    AND
    (CASE
	    WHEN $3::timestamp IS NOT NULL THEN gm.joined_at > $3::timestamp
	    ELSE TRUE
    END)
	ORDER BY gm.joined_at DESC
	LIMIT $4
),

user_roles_cte AS (
	SELECT gru.user_id, ARRAY_AGG(gru.role_id)::uuid[] AS roles
	FROM guild_role_users gru
    INNER JOIN guild_roles gr ON gr.id = gru.role_id AND gr.guild_id = $1
	INNER JOIN guild_member_cte gmcte ON gmcte.id = gru.user_id
	GROUP BY gru.user_id
)

SELECT gmcte.joined_at, gmcte.display_name, gmcte.id, gmcte.username, gmcte.public_flags, gmcte.attachment_id, urcte.roles
FROM guild_member_cte gmcte
INNER JOIN user_roles_cte urcte ON urcte.user_id = gmcte.id
`

type GetManyGuildMembersByGuildIDParams struct {
	GuildID      uuid.UUID
	Before       pgtype.Timestamp
	After        pgtype.Timestamp
	ResultsLimit int64
}

type GetManyGuildMembersByGuildIDRow struct {
	JoinedAt     pgtype.Timestamp
	DisplayName  string
	ID           uuid.UUID
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
	Roles        []uuid.UUID
}

func (q *Queries) GetManyGuildMembersByGuildID(ctx context.Context, arg GetManyGuildMembersByGuildIDParams) ([]GetManyGuildMembersByGuildIDRow, error) {
	rows, err := q.db.Query(ctx, getManyGuildMembersByGuildID,
		arg.GuildID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyGuildMembersByGuildIDRow{}
	for rows.Next() {
		var i GetManyGuildMembersByGuildIDRow
		if err := rows.Scan(
			&i.JoinedAt,
			&i.DisplayName,
			&i.ID,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGuildMember = `-- name: UpdateGuildMember :execrows
UPDATE guild_members
SET nickname = $1
WHERE guild_id = $2 AND user_id = $3
`

type UpdateGuildMemberParams struct {
	Nickname pgtype.Text
	GuildID  uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) UpdateGuildMember(ctx context.Context, arg UpdateGuildMemberParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateGuildMember, arg.Nickname, arg.GuildID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

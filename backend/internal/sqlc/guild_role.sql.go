// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: guild_role.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const assignDefaultRoleToManyGuildChannels = `-- name: AssignDefaultRoleToManyGuildChannels :one
INSERT INTO
guild_role_channels
(role_id, channel_id)
SELECT
gr.id,
c.id
FROM
channels c
INNER JOIN
guild_roles gr ON gr.guild_id = c.guild_id
WHERE
c.id = ANY($1::uuid[])
AND
gr.name = '@default'
AND
gr.guild_id = $2
RETURNING
role_id
`

type AssignDefaultRoleToManyGuildChannelsParams struct {
	ChannelIds []uuid.UUID
	GuildID    uuid.UUID
}

func (q *Queries) AssignDefaultRoleToManyGuildChannels(ctx context.Context, arg AssignDefaultRoleToManyGuildChannelsParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, assignDefaultRoleToManyGuildChannels, arg.ChannelIds, arg.GuildID)
	var role_id uuid.UUID
	err := row.Scan(&role_id)
	return role_id, err
}

const assignDefaultRoleToUser = `-- name: AssignDefaultRoleToUser :one
INSERT INTO
guild_role_users
(role_id, user_id)
SELECT
gr.id,
gm.user_id
FROM
guild_members gm
INNER JOIN
guild_roles gr ON gr.guild_id = gm.guild_id
WHERE
gm.user_id = $1
AND
gr.name = '@default'
AND
gm.guild_id = $2
RETURNING
role_id
`

type AssignDefaultRoleToUserParams struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) AssignDefaultRoleToUser(ctx context.Context, arg AssignDefaultRoleToUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, assignDefaultRoleToUser, arg.UserID, arg.GuildID)
	var role_id uuid.UUID
	err := row.Scan(&role_id)
	return role_id, err
}

const assignManyRolesToGuildChannel = `-- name: AssignManyRolesToGuildChannel :execrows
INSERT INTO
guild_role_channels (role_id, channel_id)
SELECT
gr.id,
c.id
FROM
channels c
INNER JOIN
guild_roles gr ON gr.guild_id = c.guild_id
WHERE
c.id = $1
AND
gr.id = ANY($2::uuid[])
AND
gr.guild_id = $3
`

type AssignManyRolesToGuildChannelParams struct {
	ChannelID uuid.UUID
	RoleIds   []uuid.UUID
	GuildID   uuid.UUID
}

func (q *Queries) AssignManyRolesToGuildChannel(ctx context.Context, arg AssignManyRolesToGuildChannelParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignManyRolesToGuildChannel, arg.ChannelID, arg.RoleIds, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignManyRolesToUser = `-- name: AssignManyRolesToUser :execrows
INSERT INTO
guild_role_users
(role_id, user_id)
SELECT
gr.id,
gm.user_id
FROM 
guild_members gm
INNER JOIN
guild_roles gr ON gr.guild_id = gm.guild_id
WHERE
gm.user_id = $1
AND
gr.id = ANY($2::uuid[])
AND
gm.guild_id = $3
`

type AssignManyRolesToUserParams struct {
	UserID  uuid.UUID
	RoleIds []uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) AssignManyRolesToUser(ctx context.Context, arg AssignManyRolesToUserParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignManyRolesToUser, arg.UserID, arg.RoleIds, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignOwnerRoleToManyGuildChannels = `-- name: AssignOwnerRoleToManyGuildChannels :one
INSERT INTO
guild_role_channels
(role_id, channel_id)
SELECT
gr.id,
c.id
FROM
channels c
INNER JOIN
guild_roles gr ON gr.guild_id = c.guild_id
WHERE
c.id = ANY($1::uuid[])
AND
gr.name = '@owner'
AND
gr.guild_id = $2
RETURNING
role_id
`

type AssignOwnerRoleToManyGuildChannelsParams struct {
	ChannelIds []uuid.UUID
	GuildID    uuid.UUID
}

func (q *Queries) AssignOwnerRoleToManyGuildChannels(ctx context.Context, arg AssignOwnerRoleToManyGuildChannelsParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, assignOwnerRoleToManyGuildChannels, arg.ChannelIds, arg.GuildID)
	var role_id uuid.UUID
	err := row.Scan(&role_id)
	return role_id, err
}

const assignParentRolesToChannel = `-- name: AssignParentRolesToChannel :many
INSERT INTO
guild_role_channels
(role_id, channel_id)
SELECT
grc.role_id,
$1
FROM
guild_role_channels grc
WHERE
channel_id = $2
RETURNING
role_id
`

type AssignParentRolesToChannelParams struct {
	ChannelID pgtype.UUID
	ParentID  pgtype.UUID
}

func (q *Queries) AssignParentRolesToChannel(ctx context.Context, arg AssignParentRolesToChannelParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, assignParentRolesToChannel, arg.ChannelID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var role_id uuid.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignRoleToManyGuildChannels = `-- name: AssignRoleToManyGuildChannels :execrows
INSERT INTO
guild_role_channels
(role_id, channel_id)
SELECT
gr.id,
c.id
FROM
channels c
INNER JOIN
guild_roles gr ON gr.guild_id = c.guild_id
WHERE
c.id = ANY($1::uuid[])
AND
gr.id = $2
AND
gr.guild_id = $3
`

type AssignRoleToManyGuildChannelsParams struct {
	ChannelIds []uuid.UUID
	RoleID     uuid.UUID
	GuildID    uuid.UUID
}

func (q *Queries) AssignRoleToManyGuildChannels(ctx context.Context, arg AssignRoleToManyGuildChannelsParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignRoleToManyGuildChannels, arg.ChannelIds, arg.RoleID, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignRoleToManyUsers = `-- name: AssignRoleToManyUsers :execrows
INSERT INTO
guild_role_users
(role_id, user_id)
SELECT
gr.id,
gm.user_id
FROM
guild_members gm
INNER JOIN
guild_roles gr ON gr.guild_id = gm.guild_id
WHERE
gm.user_id = ANY($1::uuid[])
AND
gr.id = $2
AND
gm.guild_id = $3
`

type AssignRoleToManyUsersParams struct {
	UserIds []uuid.UUID
	RoleID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) AssignRoleToManyUsers(ctx context.Context, arg AssignRoleToManyUsersParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignRoleToManyUsers, arg.UserIds, arg.RoleID, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const creatGuildRole = `-- name: CreatGuildRole :one
INSERT INTO
guild_roles
(name, creator_id, guild_id, permissions)
VALUES
($1, $2, $3, $4)
RETURNING
id, name, permissions, guild_id, creator_id, updated_at
`

type CreatGuildRoleParams struct {
	Name        string
	CreatorID   uuid.UUID
	GuildID     uuid.UUID
	Permissions int32
}

func (q *Queries) CreatGuildRole(ctx context.Context, arg CreatGuildRoleParams) (GuildRole, error) {
	row := q.db.QueryRow(ctx, creatGuildRole,
		arg.Name,
		arg.CreatorID,
		arg.GuildID,
		arg.Permissions,
	)
	var i GuildRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Permissions,
		&i.GuildID,
		&i.CreatorID,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGuildRole = `-- name: DeleteGuildRole :execrows
DELETE
FROM
guild_roles
WHERE
id = $1
AND
guild_id = $2
`

type DeleteGuildRoleParams struct {
	RoleID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) DeleteGuildRole(ctx context.Context, arg DeleteGuildRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGuildRole, arg.RoleID, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getDefaultGuildRole = `-- name: GetDefaultGuildRole :one
SELECT
id
FROM
guild_roles
WHERE
guild_id = $1
AND
name = '@default'
`

func (q *Queries) GetDefaultGuildRole(ctx context.Context, guildID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getDefaultGuildRole, guildID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getGuildRolePermissionsByUserIDAndChannelID = `-- name: GetGuildRolePermissionsByUserIDAndChannelID :one
Select
COALESCE(bit_or(gr.permissions), -1)::int as permissions
FROM
guild_roles gr
INNER JOIN
guild_role_users gru ON gru.role_id = gr.id
INNER JOIN
guild_role_channels grc ON grc.role_id = gr.id
WHERE
gru.user_id = $1
AND
grc.channel_id = $2
`

type GetGuildRolePermissionsByUserIDAndChannelIDParams struct {
	UserID    uuid.UUID
	ChannelID uuid.UUID
}

func (q *Queries) GetGuildRolePermissionsByUserIDAndChannelID(ctx context.Context, arg GetGuildRolePermissionsByUserIDAndChannelIDParams) (int32, error) {
	row := q.db.QueryRow(ctx, getGuildRolePermissionsByUserIDAndChannelID, arg.UserID, arg.ChannelID)
	var permissions int32
	err := row.Scan(&permissions)
	return permissions, err
}

const getGuildRolePermissionsByUserIDAndGuildID = `-- name: GetGuildRolePermissionsByUserIDAndGuildID :one
Select
COALESCE(bit_or(gr.permissions), -1)::int as permissions
FROM
guild_roles gr
INNER JOIN
guild_role_users gru ON gru.role_id = gr.id
WHERE
gr.guild_id = $1
AND
gru.user_id = $2
`

type GetGuildRolePermissionsByUserIDAndGuildIDParams struct {
	GuildID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) GetGuildRolePermissionsByUserIDAndGuildID(ctx context.Context, arg GetGuildRolePermissionsByUserIDAndGuildIDParams) (int32, error) {
	row := q.db.QueryRow(ctx, getGuildRolePermissionsByUserIDAndGuildID, arg.GuildID, arg.UserID)
	var permissions int32
	err := row.Scan(&permissions)
	return permissions, err
}

const getManyGuildRoleIDsByUserID = `-- name: GetManyGuildRoleIDsByUserID :many
SELECT
role_id
FROM
guild_role_users
WHERE
user_id = $1
`

func (q *Queries) GetManyGuildRoleIDsByUserID(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getManyGuildRoleIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var role_id uuid.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyGuildRolesByGuildID = `-- name: GetManyGuildRolesByGuildID :many
SELECT
id, name, permissions, guild_id, creator_id, updated_at
FROM
guild_roles
WHERE
guild_id = $1
`

func (q *Queries) GetManyGuildRolesByGuildID(ctx context.Context, guildID uuid.UUID) ([]GuildRole, error) {
	rows, err := q.db.Query(ctx, getManyGuildRolesByGuildID, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GuildRole{}
	for rows.Next() {
		var i GuildRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Permissions,
			&i.GuildID,
			&i.CreatorID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleIDsByChannelID = `-- name: GetRoleIDsByChannelID :many
Select
grc.role_id
FROM
guild_role_channels grc
WHERE
grc.channel_id = $1
`

func (q *Queries) GetRoleIDsByChannelID(ctx context.Context, channelID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getRoleIDsByChannelID, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var role_id uuid.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncedChannelIDsByParentID = `-- name: GetSyncedChannelIDsByParentID :many
WITH parent_channel_roles_cte AS (
	SELECT
	ARRAY_AGG(role_id) role_ids
	FROM
	guild_role_channels
	WHERE
	channel_id = $1::uuid
),

child_channels_roles_cte AS (
	SELECT
	c.id,
	ARRAY_AGG(grc.role_id) role_ids
	FROM
	guild_role_channels grc
	INNER JOIN
	channels c ON c.id = grc.channel_id
	WHERE
    c.parent_id = $1::uuid
	GROUP BY
    c.id
)

SELECT
ccrcte.id
FROM
child_channels_roles_cte ccrcte, parent_channel_roles_cte pcrcte
WHERE
array_length(ccrcte.role_ids, 1) = array_length(pcrcte.role_ids, 1)
AND
ccrcte.role_ids @> pcrcte.role_ids
`

func (q *Queries) GetSyncedChannelIDsByParentID(ctx context.Context, parentID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getSyncedChannelIDsByParentID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unassignAllRolesFromChannel = `-- name: UnassignAllRolesFromChannel :many
DELETE
FROM
guild_role_channels
WHERE
channel_id = $1
RETURNING
role_id
`

func (q *Queries) UnassignAllRolesFromChannel(ctx context.Context, channelID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, unassignAllRolesFromChannel, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var role_id uuid.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unassignAllRolesFromUser = `-- name: UnassignAllRolesFromUser :many
DELETE
FROM
guild_role_users
WHERE
user_id = $1
AND
role_id IN (
    SELECT
        id
    FROM
        guild_roles
    WHERE
        guild_id = $2
)
RETURNING
role_id
`

type UnassignAllRolesFromUserParams struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) UnassignAllRolesFromUser(ctx context.Context, arg UnassignAllRolesFromUserParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, unassignAllRolesFromUser, arg.UserID, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var role_id uuid.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unassignRoleFromGuildChannel = `-- name: UnassignRoleFromGuildChannel :execrows
DELETE
FROM
guild_role_channels
WHERE
role_id = $1
AND
channel_id = $2
`

type UnassignRoleFromGuildChannelParams struct {
	RoleID    uuid.UUID
	ChannelID uuid.UUID
}

func (q *Queries) UnassignRoleFromGuildChannel(ctx context.Context, arg UnassignRoleFromGuildChannelParams) (int64, error) {
	result, err := q.db.Exec(ctx, unassignRoleFromGuildChannel, arg.RoleID, arg.ChannelID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const unassignRoleFromManyGuildChannels = `-- name: UnassignRoleFromManyGuildChannels :execrows
DELETE FROM
guild_role_channels
WHERE 
role_id = $1
AND
channel_id = ANY($2::uuid[])
`

type UnassignRoleFromManyGuildChannelsParams struct {
	RoleID     uuid.UUID
	ChannelIds []uuid.UUID
}

func (q *Queries) UnassignRoleFromManyGuildChannels(ctx context.Context, arg UnassignRoleFromManyGuildChannelsParams) (int64, error) {
	result, err := q.db.Exec(ctx, unassignRoleFromManyGuildChannels, arg.RoleID, arg.ChannelIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const unassignRoleFromUser = `-- name: UnassignRoleFromUser :execrows
DELETE
FROM
guild_role_users
WHERE
role_id = $1
AND
user_id = $2
`

type UnassignRoleFromUserParams struct {
	RoleID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) UnassignRoleFromUser(ctx context.Context, arg UnassignRoleFromUserParams) (int64, error) {
	result, err := q.db.Exec(ctx, unassignRoleFromUser, arg.RoleID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateGuildRole = `-- name: UpdateGuildRole :one
UPDATE
guild_roles
SET
name = $1,
permissions = $2,
updated_at = NOW()
WHERE
id = $3
AND
guild_id = $4
RETURNING
id, name, permissions, guild_id, creator_id, updated_at
`

type UpdateGuildRoleParams struct {
	Name        string
	Permissions int32
	RoleID      uuid.UUID
	GuildID     uuid.UUID
}

func (q *Queries) UpdateGuildRole(ctx context.Context, arg UpdateGuildRoleParams) (GuildRole, error) {
	row := q.db.QueryRow(ctx, updateGuildRole,
		arg.Name,
		arg.Permissions,
		arg.RoleID,
		arg.GuildID,
	)
	var i GuildRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Permissions,
		&i.GuildID,
		&i.CreatorID,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: guild_ban.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createGuildBan = `-- name: CreateGuildBan :execrows
INSERT INTO guild_bans
(user_id, reason, guild_id, creator_id)
SELECT id, $1, $2, $3
FROM users
WHERE id = $4
`

type CreateGuildBanParams struct {
	Reason    string
	GuildID   uuid.UUID
	CreatorID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) CreateGuildBan(ctx context.Context, arg CreateGuildBanParams) (int64, error) {
	result, err := q.db.Exec(ctx, createGuildBan,
		arg.Reason,
		arg.GuildID,
		arg.CreatorID,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteGuildBan = `-- name: DeleteGuildBan :execrows
DELETE FROM guild_bans
WHERE user_id  = $1 AND guild_id = $2
`

type DeleteGuildBanParams struct {
	UserID  uuid.UUID
	GuildID uuid.UUID
}

func (q *Queries) DeleteGuildBan(ctx context.Context, arg DeleteGuildBanParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGuildBan, arg.UserID, arg.GuildID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getGuildBanCountByUserIDAndGuildID = `-- name: GetGuildBanCountByUserIDAndGuildID :execrows
SELECT
user_id
FROM
guild_bans
WHERE
guild_id = $1
AND
user_id = $2
`

type GetGuildBanCountByUserIDAndGuildIDParams struct {
	GuildID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) GetGuildBanCountByUserIDAndGuildID(ctx context.Context, arg GetGuildBanCountByUserIDAndGuildIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, getGuildBanCountByUserIDAndGuildID, arg.GuildID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getManyGuildBansByGuildID = `-- name: GetManyGuildBansByGuildID :many
SELECT
    gb.banned_at,
    gb.reason,
    u.id,
    u.display_name,
    u.username,
    u.public_flags,
    ua.attachment_id
FROM guild_bans gb
INNER JOIN users u ON u.id = gb.user_id
LEFT JOIN user_attachments ua ON ua.user_id = u.id
WHERE gb.guild_id = $1 AND 
    (CASE
        WHEN $2::uuid IS NOT NULL THEN gb.user_id < $2::uuid
        ELSE TRUE
    END)
    AND
    (CASE
	    WHEN $3::uuid IS NOT NULL THEN gb.user_id > $3::uuid
	    ELSE TRUE
    END)
ORDER BY gb.user_id DESC
LIMIT $4
`

type GetManyGuildBansByGuildIDParams struct {
	GuildID      uuid.UUID
	Before       pgtype.UUID
	After        pgtype.UUID
	ResultsLimit int64
}

type GetManyGuildBansByGuildIDRow struct {
	BannedAt     pgtype.Timestamp
	Reason       string
	ID           uuid.UUID
	DisplayName  string
	Username     string
	PublicFlags  int32
	AttachmentID pgtype.UUID
}

func (q *Queries) GetManyGuildBansByGuildID(ctx context.Context, arg GetManyGuildBansByGuildIDParams) ([]GetManyGuildBansByGuildIDRow, error) {
	rows, err := q.db.Query(ctx, getManyGuildBansByGuildID,
		arg.GuildID,
		arg.Before,
		arg.After,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetManyGuildBansByGuildIDRow{}
	for rows.Next() {
		var i GetManyGuildBansByGuildIDRow
		if err := rows.Scan(
			&i.BannedAt,
			&i.Reason,
			&i.ID,
			&i.DisplayName,
			&i.Username,
			&i.PublicFlags,
			&i.AttachmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
